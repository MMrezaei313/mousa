
"""
Ù…Ø´Ø§ÙˆØ± Ù¾ÙˆØ²ÛŒØ´Ù† MousaTrade
ØªÙˆÙ„ÛŒØ¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ù‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Tuple, Optional
from datetime import datetime
import logging
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class PositionType(Enum):
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"

class RiskLevel(Enum):
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    VERY_HIGH = "VERY_HIGH"

@dataclass
class PositionAdvice:
    symbol: str
    position_type: PositionType
    confidence: float
    entry_range: Tuple[float, float]
    targets: List[float]
    stop_loss: float
    risk_reward_ratio: float
    risk_level: RiskLevel
    timeframe: str
    reasoning: Dict
    timestamp: datetime

class PositionAdvisor:
    """Ù…Ø´Ø§ÙˆØ± Ù¾ÙˆØ²ÛŒØ´Ù†â€ŒÙ‡Ø§ÛŒ Ù…Ø¹Ø§Ù…Ù„Ø§ØªÛŒ"""
    
    def __init__(self):
        self.min_confidence = 0.6
        self.max_risk_reward = 0.1  # Ø­Ø¯Ø§Ú©Ø«Ø± Ø±ÛŒØ³Ú© 10%
        self.position_sizing_rules = {
            RiskLevel.LOW: 0.05,      # 5% Ø³Ø±Ù…Ø§ÛŒÙ‡
            RiskLevel.MEDIUM: 0.03,   # 3% Ø³Ø±Ù…Ø§ÛŒÙ‡  
            RiskLevel.HIGH: 0.01,     # 1% Ø³Ø±Ù…Ø§ÛŒÙ‡
            RiskLevel.VERY_HIGH: 0.005 # 0.5% Ø³Ø±Ù…Ø§ÛŒÙ‡
        }
    
    def get_position_advice(self, symbol: str, market_data: pd.DataFrame,
                          technical_analysis: Dict, fundamental_analysis: Dict,
                          sentiment_analysis: Dict) -> PositionAdvice:
        """Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ ØªØ±Ú©ÛŒØ¨ÛŒ"""
        try:
            # ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„ Ø¨Ø±Ø§ÛŒ ØªØ¹ÛŒÛŒÙ† Ø¬Ù‡Øª
            technical_direction = self._analyze_technical_direction(technical_analysis)
            
            # ØªØ­Ù„ÛŒÙ„ ÙØ§Ù†Ø¯Ø§Ù…Ù†ØªØ§Ù„ Ø¨Ø±Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ
            fundamental_score = fundamental_analysis.get('fundamental_score', 0.5)
            
            # ØªØ­Ù„ÛŒÙ„ Ø§Ø­Ø³Ø§Ø³Ø§Øª Ø¨Ø±Ø§ÛŒ ØªØ§ÛŒÛŒØ¯
            sentiment_score = sentiment_analysis.get('overall_score', 0.5)
            
            # ØªØ±Ú©ÛŒØ¨ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ù†Ù‡Ø§ÛŒÛŒ
            position_type, confidence = self._combine_analyses(
                technical_direction, fundamental_score, sentiment_score
            )
            
            # Ø§Ú¯Ø± Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ú©Ø§ÙÛŒ Ù†ÛŒØ³ØªØŒ Ù¾ÙˆØ²ÛŒØ´Ù† Ø®Ù†Ø«ÛŒ
            if confidence < self.min_confidence:
                position_type = PositionType.NEUTRAL
                confidence = 0.5
            
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ù‚Ø§Ø· ÙˆØ±ÙˆØ¯ØŒ Ø§Ù‡Ø¯Ø§Ù Ùˆ Ø­Ø¯ Ø¶Ø±Ø±
            current_price = market_data['close'].iloc[-1]
            entry_range = self._calculate_entry_range(current_price, position_type, technical_analysis)
            targets = self._calculate_targets(current_price, position_type, technical_analysis)
            stop_loss = self._calculate_stop_loss(current_price, position_type, technical_analysis)
            
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ø³Ø¨Øª Ø±ÛŒØ³Ú© Ø¨Ù‡ Ø±ÛŒÙˆØ§Ø±Ø¯
            risk_reward_ratio = self._calculate_risk_reward_ratio(
                current_price, entry_range, targets, stop_loss, position_type
            )
            
            # Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø³Ø·Ø­ Ø±ÛŒØ³Ú©
            risk_level = self._assess_risk_level(
                confidence, risk_reward_ratio, technical_analysis, fundamental_analysis
            )
            
            # Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù†Ù‡Ø§ÛŒÛŒ
            advice = PositionAdvice(
                symbol=symbol,
                position_type=position_type,
                confidence=round(confidence, 2),
                entry_range=entry_range,
                targets=targets,
                stop_loss=stop_loss,
                risk_reward_ratio=round(risk_reward_ratio, 2),
                risk_level=risk_level,
                timeframe="1h",
                reasoning={
                    "technical": technical_direction,
                    "fundamental_score": fundamental_score,
                    "sentiment_score": sentiment_score,
                    "combined_confidence": confidence
                },
                timestamp=datetime.now()
            )
            
            logger.info(f"ğŸ¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø±Ø§ÛŒ {symbol}: {position_type.value} Ø¨Ø§ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† {confidence}")
            
            return advice
            
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø±Ø§ÛŒ {symbol}: {e}")
            return self._get_neutral_advice(symbol)
    
    def _analyze_technical_direction(self, technical_analysis: Dict) -> Dict:
        """ØªØ¹ÛŒÛŒÙ† Ø¬Ù‡Øª Ø¨Ø± Ø§Ø³Ø§Ø³ ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„"""
        try:
            trend = technical_analysis.get('trend', {})
            signals = technical_analysis.get('signals', [])
            summary = technical_analysis.get('summary', {})
            
            # ØªØ­Ù„ÛŒÙ„ Ø±ÙˆÙ†Ø¯
            trend_direction = trend.get('direction', 'Ø¨Ø¯ÙˆÙ† Ø±ÙˆÙ†Ø¯ Ù…Ø´Ø®Øµ')
            trend_strength = trend.get('strength', 0.5)
            
            # Ø´Ù…Ø§Ø±Ø´ Ø³ÛŒÚ¯Ù†Ø§Ù„â€ŒÙ‡Ø§
            buy_signals = len([s for s in signals if hasattr(s, 'signal') and s.signal == 'BUY'])
            sell_signals = len([s for s in signals if hasattr(s, 'signal') and s.signal == 'SELL'])
            
            # ØªØ­Ù„ÛŒÙ„ Ù†Ù‡Ø§ÛŒÛŒ ØªÚ©Ù†ÛŒÚ©Ø§Ù„
            if trend_direction == "ØµØ¹ÙˆØ¯ÛŒ" and buy_signals > sell_signals and trend_strength > 0.6:
                return {"direction": "LONG", "strength": trend_strength}
            elif trend_direction == "Ù†Ø²ÙˆÙ„ÛŒ" and sell_signals > buy_signals and trend_strength > 0.6:
                return {"direction": "SHORT", "strength": trend_strength}
            else:
                return {"direction": "NEUTRAL", "strength": 0.5}
                
        except Exception as e:
            logger.warning(f"Ø®Ø·Ø§ Ø¯Ø± ØªØ­Ù„ÛŒÙ„ Ø¬Ù‡Øª ØªÚ©Ù†ÛŒÚ©Ø§Ù„: {e}")
            return {"direction": "NEUTRAL", "strength": 0.5}
    
    def _combine_analyses(self, technical_direction: Dict, 
                         fundamental_score: float, sentiment_score: float) -> Tuple[PositionType, float]:
        """ØªØ±Ú©ÛŒØ¨ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù Ø¨Ø±Ø§ÛŒ ØªØµÙ…ÛŒÙ…â€ŒÚ¯ÛŒØ±ÛŒ Ù†Ù‡Ø§ÛŒÛŒ"""
        
        tech_direction = technical_direction.get('direction', 'NEUTRAL')
        tech_strength = technical_direction.get('strength', 0.5)
        
        # ÙˆØ²Ù†â€ŒØ¯Ù‡ÛŒ Ø¨Ù‡ ØªØ­Ù„ÛŒÙ„â€ŒÙ‡Ø§
        tech_weight = 0.5
        fundamental_weight = 0.3
        sentiment_weight = 0.2
        
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù…ØªÛŒØ§Ø² ØªØ±Ú©ÛŒØ¨ÛŒ
        if tech_direction == "LONG":
            base_score = 0.7
        elif tech_direction == "SHORT":
            base_score = 0.3
        else:
            base_score = 0.5
        
        # Ø§Ø¹Ù…Ø§Ù„ ÙˆØ²Ù†â€ŒÙ‡Ø§
        combined_score = (
            base_score * tech_weight +
            fundamental_score * fundamental_weight +
            sentiment_score * sentiment_weight
        )
        
        # ØªØ¹Ø¯ÛŒÙ„ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù‚Ø¯Ø±Øª ØªØ­Ù„ÛŒÙ„ ØªÚ©Ù†ÛŒÚ©Ø§Ù„
        combined_score = combined_score * (0.5 + tech_strength * 0.5)
        
        # ØªØ¹ÛŒÛŒÙ† Ø¬Ù‡Øª Ùˆ Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ù†Ù‡Ø§ÛŒÛŒ
        if combined_score > 0.6:
            position_type = PositionType.LONG
            confidence = min(combined_score, 0.95)
        elif combined_score < 0.4:
            position_type = PositionType.SHORT
            confidence = min(1 - combined_score, 0.95)
        else:
            position_type = PositionType.NEUTRAL
            confidence = 0.5
        
        return position_type, confidence
    
    def _calculate_entry_range(self, current_price: float, position_type: PositionType,
                             technical_analysis: Dict) -> Tuple[float, float]:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ ÙˆØ±ÙˆØ¯"""
        
        support_resistance = technical_analysis.get('support_resistance', {})
        volatility = technical_analysis.get('volatility', {}).get('daily_volatility', 0.02)
        
        if position_type == PositionType.LONG:
            # Ø¨Ø±Ø§ÛŒ Ù„Ø§Ù†Ú¯: ÙˆØ±ÙˆØ¯ Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø­Ù…Ø§ÛŒØª ÛŒØ§ Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
            nearest_support = support_resistance.get('nearest_support', current_price * 0.98)
            entry_low = min(current_price * 0.995, nearest_support)
            entry_high = current_price * 1.01
            
        elif position_type == PositionType.SHORT:
            # Ø¨Ø±Ø§ÛŒ Ø´ÙˆØ±Øª: ÙˆØ±ÙˆØ¯ Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù…Ù‚Ø§ÙˆÙ…Øª ÛŒØ§ Ù‚ÛŒÙ…Øª ÙØ¹Ù„ÛŒ
            nearest_resistance = support_resistance.get('nearest_resistance', current_price * 1.02)
            entry_low = current_price * 0.99
            entry_high = max(current_price * 1.005, nearest_resistance)
            
        else:  # NEUTRAL
            entry_low = current_price * 0.99
            entry_high = current_price * 1.01
        
        # ØªØ¹Ø¯ÛŒÙ„ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ³Ø§Ù†
        volatility_adjustment = volatility * 2
        entry_low = entry_low * (1 - volatility_adjustment)
        entry_high = entry_high * (1 + volatility_adjustment)
        
        return (round(entry_low, 4), round(entry_high, 4))
    
    def _calculate_targets(self, current_price: float, position_type: PositionType,
                          technical_analysis: Dict) -> List[float]:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§Ù‡Ø¯Ø§Ù Ù‚ÛŒÙ…ØªÛŒ"""
        
        support_resistance = technical_analysis.get('support_resistance', {})
        volatility = technical_analysis.get('volatility', {}).get('daily_volatility', 0.02)
        
        if position_type == PositionType.LONG:
            # Ø§Ù‡Ø¯Ø§Ù Ø¨Ø±Ø§ÛŒ Ù„Ø§Ù†Ú¯: Ø³Ø·ÙˆØ­ Ù…Ù‚Ø§ÙˆÙ…Øª
            resistance_levels = support_resistance.get('resistance_levels', [])
            if resistance_levels:
                # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø³Ø·ÙˆØ­ Ù…Ù‚Ø§ÙˆÙ…Øª ÙˆØ§Ù‚Ø¹ÛŒ
                targets = [level for level in resistance_levels if level > current_price][:3]
            else:
                # Ø§Ù‡Ø¯Ø§Ù Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ³Ø§Ù†
                target1 = current_price * (1 + volatility * 3)  # 3 Ø¨Ø±Ø§Ø¨Ø± Ù†ÙˆØ³Ø§Ù†
                target2 = current_price * (1 + volatility * 5)  # 5 Ø¨Ø±Ø§Ø¨Ø± Ù†ÙˆØ³Ø§Ù†
                target3 = current_price * (1 + volatility * 8)  # 8 Ø¨Ø±Ø§Ø¨Ø± Ù†ÙˆØ³Ø§Ù†
                targets = [target1, target2, target3]
                
        elif position_type == PositionType.SHORT:
            # Ø§Ù‡Ø¯Ø§Ù Ø¨Ø±Ø§ÛŒ Ø´ÙˆØ±Øª: Ø³Ø·ÙˆØ­ Ø­Ù…Ø§ÛŒØª
            support_levels = support_resistance.get('support_levels', [])
            if support_levels:
                # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø³Ø·ÙˆØ­ Ø­Ù…Ø§ÛŒØª ÙˆØ§Ù‚Ø¹ÛŒ
                targets = [level for level in support_levels if level < current_price][:3]
            else:
                # Ø§Ù‡Ø¯Ø§Ù Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ³Ø§Ù†
                target1 = current_price * (1 - volatility * 3)  # 3 Ø¨Ø±Ø§Ø¨Ø± Ù†ÙˆØ³Ø§Ù†
                target2 = current_price * (1 - volatility * 5)  # 5 Ø¨Ø±Ø§Ø¨Ø± Ù†ÙˆØ³Ø§Ù†
                target3 = current_price * (1 - volatility * 8)  # 8 Ø¨Ø±Ø§Ø¨Ø± Ù†ÙˆØ³Ø§Ù†
                targets = [target1, target2, target3]
                
        else:  # NEUTRAL
            targets = []
        
        # Ú¯Ø±Ø¯ Ú©Ø±Ø¯Ù† Ùˆ Ù…Ø­Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† Ø¨Ù‡ Û² Ù‡Ø¯Ù
        targets = [round(target, 4) for target in targets][:2]
        return targets
    
    def _calculate_stop_loss(self, current_price: float, position_type: PositionType,
                           technical_analysis: Dict) -> float:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¯ Ø¶Ø±Ø±"""
        
        support_resistance = technical_analysis.get('support_resistance', {})
        volatility = technical_analysis.get('volatility', {}).get('daily_volatility', 0.02)
        
        if position_type == PositionType.LONG:
            # Ø§Ø³ØªØ§Ù¾ Ù„Ø§Ø³ Ø¨Ø±Ø§ÛŒ Ù„Ø§Ù†Ú¯: Ø²ÛŒØ± Ø­Ù…Ø§ÛŒØª ÛŒØ§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ³Ø§Ù†
            nearest_support = support_resistance.get('nearest_support', current_price * 0.98)
            stop_loss_based_support = nearest_support * 0.99  # Ú©Ù…ÛŒ Ø²ÛŒØ± Ø­Ù…Ø§ÛŒØª
            stop_loss_based_volatility = current_price * (1 - volatility * 4)  # 4 Ø¨Ø±Ø§Ø¨Ø± Ù†ÙˆØ³Ø§Ù†
            
            stop_loss = min(stop_loss_based_support, stop_loss_based_volatility)
            
        elif position_type == PositionType.SHORT:
            # Ø§Ø³ØªØ§Ù¾ Ù„Ø§Ø³ Ø¨Ø±Ø§ÛŒ Ø´ÙˆØ±Øª: Ø¨Ø§Ù„Ø§ÛŒ Ù…Ù‚Ø§ÙˆÙ…Øª ÛŒØ§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ³Ø§Ù†
            nearest_resistance = support_resistance.get('nearest_resistance', current_price * 1.02)
            stop_loss_based_resistance = nearest_resistance * 1.01  # Ú©Ù…ÛŒ Ø¨Ø§Ù„Ø§ÛŒ Ù…Ù‚Ø§ÙˆÙ…Øª
            stop_loss_based_volatility = current_price * (1 + volatility * 4)  # 4 Ø¨Ø±Ø§Ø¨Ø± Ù†ÙˆØ³Ø§Ù†
            
            stop_loss = max(stop_loss_based_resistance, stop_loss_based_volatility)
            
        else:  # NEUTRAL
            stop_loss = 0.0
        
        return round(stop_loss, 4) if stop_loss else 0.0
    
    def _calculate_risk_reward_ratio(self, current_price: float, entry_range: Tuple[float, float],
                                   targets: List[float], stop_loss: float, 
                                   position_type: PositionType) -> float:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†Ø³Ø¨Øª Ø±ÛŒØ³Ú© Ø¨Ù‡ Ø±ÛŒÙˆØ§Ø±Ø¯"""
        
        if not targets or stop_loss == 0:
            return 0.0
        
        # Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù†Ù‚Ø·Ù‡ ÙˆØ±ÙˆØ¯
        avg_entry = (entry_range[0] + entry_range[1]) / 2
        
        if position_type == PositionType.LONG:
            # Ø±ÛŒØ³Ú©: ÙØ§ØµÙ„Ù‡ ÙˆØ±ÙˆØ¯ ØªØ§ Ø§Ø³ØªØ§Ù¾ Ù„Ø§Ø³
            risk = avg_entry - stop_loss
            # Ø±ÛŒÙˆØ§Ø±Ø¯: ÙØ§ØµÙ„Ù‡ ÙˆØ±ÙˆØ¯ ØªØ§ Ø§ÙˆÙ„ÛŒÙ† Ù‡Ø¯Ù
            reward = targets[0] - avg_entry
            
        elif position_type == PositionType.SHORT:
            # Ø±ÛŒØ³Ú©: ÙØ§ØµÙ„Ù‡ Ø§Ø³ØªØ§Ù¾ Ù„Ø§Ø³ ØªØ§ ÙˆØ±ÙˆØ¯
            risk = stop_loss - avg_entry
            # Ø±ÛŒÙˆØ§Ø±Ø¯: ÙØ§ØµÙ„Ù‡ Ø§ÙˆÙ„ÛŒÙ† Ù‡Ø¯Ù ØªØ§ ÙˆØ±ÙˆØ¯
            reward = avg_entry - targets[0]
            
        else:
            return 0.0
        
        if risk <= 0:
            return 0.0
        
        risk_reward_ratio = risk / (avg_entry if avg_entry > 0 else 1)
        return min(risk_reward_ratio, 0.2)  # Ø­Ø¯Ø§Ú©Ø«Ø± 20% Ø±ÛŒØ³Ú©
    
    def _assess_risk_level(self, confidence: float, risk_reward_ratio: float,
                          technical_analysis: Dict, fundamental_analysis: Dict) -> RiskLevel:
        """Ø§Ø±Ø²ÛŒØ§Ø¨ÛŒ Ø³Ø·Ø­ Ø±ÛŒØ³Ú©"""
        
        risk_score = 0.0
        
        # ØªØ§Ø«ÛŒØ± Ø§Ø·Ù…ÛŒÙ†Ø§Ù†
        risk_score += (1 - confidence) * 0.4
        
        # ØªØ§Ø«ÛŒØ± Ù†Ø³Ø¨Øª Ø±ÛŒØ³Ú© Ø¨Ù‡ Ø±ÛŒÙˆØ§Ø±Ø¯
        risk_score += min(risk_reward_ratio * 5, 0.4)  # Ù†Ø±Ù…Ø§Ù„Ø§ÛŒØ² Ø¨Ù‡ 0-0.4
        
        # ØªØ§Ø«ÛŒØ± Ù†ÙˆØ³Ø§Ù†
        volatility = technical_analysis.get('volatility', {}).get('daily_volatility', 0.02)
        risk_score += min(volatility * 10, 0.2)  # Ù†Ø±Ù…Ø§Ù„Ø§ÛŒØ² Ø¨Ù‡ 0-0.2
        
        # ØªØ¹ÛŒÛŒÙ† Ø³Ø·Ø­ Ø±ÛŒØ³Ú© Ù†Ù‡Ø§ÛŒÛŒ
        if risk_score < 0.3:
            return RiskLevel.LOW
        elif risk_score < 0.5:
            return RiskLevel.MEDIUM
        elif risk_score < 0.7:
            return RiskLevel.HIGH
        else:
            return RiskLevel.VERY_HIGH
    
    def get_position_size(self, account_balance: float, risk_level: RiskLevel) -> float:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø§ÛŒØ² Ù¾ÙˆØ²ÛŒØ´Ù† Ø¨Ø± Ø§Ø³Ø§Ø³ Ø³Ø·Ø­ Ø±ÛŒØ³Ú©"""
        risk_percentage = self.position_sizing_rules.get(risk_level, 0.01)
        return account_balance * risk_percentage
    
    def validate_advice(self, advice: PositionAdvice) -> bool:
        """Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ù¾ÙˆØ²ÛŒØ´Ù†"""
        try:
            # Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø·Ù…ÛŒÙ†Ø§Ù†
            if advice.confidence < self.min_confidence:
                return False
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ù†Ø³Ø¨Øª Ø±ÛŒØ³Ú© Ø¨Ù‡ Ø±ÛŒÙˆØ§Ø±Ø¯
            if advice.risk_reward_ratio > self.max_risk_reward:
                return False
            
            # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ù†Ø·Ù‚ÛŒ Ø¨ÙˆØ¯Ù† Ø§Ù‡Ø¯Ø§Ù
            if advice.position_type == PositionType.LONG:
                if any(target <= advice.entry_range[0] for target in advice.targets):
                    return False
                if advice.stop_loss >= advice.entry_range[0]:
                    return False
                    
            elif advice.position_type == PositionType.SHORT:
                if any(target >= advice.entry_range[1] for target in advice.targets):
                    return False
                if advice.stop_loss <= advice.entry_range[1]:
                    return False
            
            return True
            
        except Exception as e:
            logger.warning(f"Ø®Ø·Ø§ Ø¯Ø± Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯: {e}")
            return False
    
    def _get_neutral_advice(self, symbol: str) -> PositionAdvice:
        """Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø®Ù†Ø«ÛŒ Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§"""
        return PositionAdvice(
            symbol=symbol,
            position_type=PositionType.NEUTRAL,
            confidence=0.5,
            entry_range=(0, 0),
            targets=[],
            stop_loss=0,
            risk_reward_ratio=0,
            risk_level=RiskLevel.LOW,
            timeframe="1h",
            reasoning={"error": "ØªØ­Ù„ÛŒÙ„ Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯"},
            timestamp=datetime.now()
        )
