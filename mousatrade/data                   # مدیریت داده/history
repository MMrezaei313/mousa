"""
مدیریت داده‌های تاریخی
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import sqlite3
from pathlib import Path
import logging
import json

logger = logging.getLogger(__name__)

class HistoricalDataManager:
    """مدیریت داده‌های تاریخی"""
    
    def __init__(self, db_path: str = "data/historical_data.db"):
        self.db_path = Path(db_path)
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_database()
    
    def _init_database(self):
        """ایجاد دیتابیس داده‌های تاریخی"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # جدول داده‌های OHLCV
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS ohlcv_data (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    symbol TEXT NOT NULL,
                    timeframe TEXT NOT NULL,
                    timestamp TEXT NOT NULL,
                    open REAL NOT NULL,
                    high REAL NOT NULL,
                    low REAL NOT NULL,
                    close REAL NOT NULL,
                    volume REAL NOT NULL,
                    created_at TEXT DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(symbol, timeframe, timestamp)
                )
            ''')
            
            # جدول متادیتای داده‌ها
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS data_metadata (
                    symbol TEXT NOT NULL,
                    timeframe TEXT NOT NULL,
                    last_update TEXT,
                    data_count INTEGER,
                    start_date TEXT,
                    end_date TEXT,
                    PRIMARY KEY (symbol, timeframe)
                )
            ''')
            
            # ایجاد ایندکس‌ها
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_symbol_timeframe ON ohlcv_data(symbol, timeframe)')
            cursor.execute('CREATE INDEX IF NOT EXISTS idx_timestamp ON ohlcv_data(timestamp)')
            
            conn.commit()
            conn.close()
            logger.info("دیتابیس داده‌های تاریخی راه‌اندازی شد")
            
        except Exception as e:
            logger.error(f"خطا در راه‌اندازی دیتابیس تاریخی: {e}")
    
    def save_ohlcv_data(self, symbol: str, timeframe: str, data: pd.DataFrame) -> bool:
        """ذخیره داده‌های OHLCV"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # تبدیل DataFrame به لیست رکوردها
            records = []
            for idx, row in data.iterrows():
                records.append((
                    symbol,
                    timeframe,
                    idx.isoformat() if hasattr(idx, 'isoformat') else str(idx),
                    row['open'],
                    row['high'], 
                    row['low'],
                    row['close'],
                    row['volume']
                ))
            
            # درج داده‌ها
            cursor.executemany('''
                INSERT OR REPLACE INTO ohlcv_data 
                (symbol, timeframe, timestamp, open, high, low, close, volume)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            ''', records)
            
            # بروزرسانی متادیتا
            self._update_metadata(symbol, timeframe, data, cursor)
            
            conn.commit()
            conn.close()
            
            logger.info(f"ذخیره {len(records)} کندل برای {symbol} ({timeframe})")
            return True
            
        except Exception as e:
            logger.error(f"خطا در ذخیره داده‌های {symbol}: {e}")
            return False
    
    def load_ohlcv_data(self, symbol: str, timeframe: str, 
                       start_date: Optional[datetime] = None,
                       end_date: Optional[datetime] = None,
                       limit: Optional[int] = None) -> pd.DataFrame:
        """بارگذاری داده‌های OHLCV"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            query = '''
                SELECT timestamp, open, high, low, close, volume
                FROM ohlcv_data 
                WHERE symbol = ? AND timeframe = ?
            '''
            params = [symbol, timeframe]
            
            if start_date:
                query += ' AND timestamp >= ?'
                params.append(start_date.isoformat())
            
            if end_date:
                query += ' AND timestamp <= ?'
                params.append(end_date.isoformat())
            
            query += ' ORDER BY timestamp ASC'
            
            if limit:
                query += ' LIMIT ?'
                params.append(limit)
            
            df = pd.read_sql_query(query, conn, params=params, 
                                 parse_dates=['timestamp'], 
                                 index_col='timestamp')
            conn.close()
            
            logger.info(f"بارگذاری {len(df)} کندل برای {symbol} ({timeframe})")
            return df
            
        except Exception as e:
            logger.error(f"خطا در بارگذاری داده‌های {symbol}: {e}")
            return pd.DataFrame()
    
    def get_available_symbols(self) -> List[str]:
        """دریافت لیست نمادهای available"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute('SELECT DISTINCT symbol FROM ohlcv_data')
            symbols = [row[0] for row in cursor.fetchall()]
            
            conn.close()
            return symbols
            
        except Exception as e:
            logger.error(f"خطا در دریافت لیست نمادها: {e}")
            return []
    
    def get_data_statistics(self, symbol: str, timeframe: str) -> Dict:
        """دریافت آمار داده‌ها"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # تعداد داده‌ها
            cursor.execute(
                'SELECT COUNT(*) FROM ohlcv_data WHERE symbol = ? AND timeframe = ?',
                (symbol, timeframe)
            )
            count = cursor.fetchone()[0]
            
            # تاریخ شروع و پایان
            cursor.execute('''
                SELECT MIN(timestamp), MAX(timestamp) 
                FROM ohlcv_data 
                WHERE symbol = ? AND timeframe = ?
            ''', (symbol, timeframe))
            
            min_date, max_date = cursor.fetchone()
            
            # آخرین بروزرسانی
            cursor.execute('''
                SELECT last_update FROM data_metadata 
                WHERE symbol = ? AND timeframe = ?
            ''', (symbol, timeframe))
            
            last_update = cursor.fetchone()
            last_update = last_update[0] if last_update else None
            
            conn.close()
            
            return {
                "symbol": symbol,
                "timeframe": timeframe,
                "data_count": count,
                "start_date": min_date,
                "end_date": max_date,
                "last_update": last_update,
                "data_span_days": self._calculate_date_span(min_date, max_date)
            }
            
        except Exception as e:
            logger.error(f"خطا در دریافت آمار داده‌های {symbol}: {e}")
            return {}
    
    def cleanup_old_data(self, older_than_days: int = 365) -> int:
        """پاکسازی داده‌های قدیمی"""
        try:
            cutoff_date = (datetime.now() - timedelta(days=older_than_days)).isoformat()
            
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute(
                'DELETE FROM ohlcv_data WHERE timestamp < ?',
                (cutoff_date,)
            )
            
            deleted_count = cursor.rowcount
            conn.commit()
            conn.close()
            
            logger.info(f"پاکسازی {deleted_count} رکورد قدیمی")
            return deleted_count
            
        except Exception as e:
            logger.error(f"خطا در پاکسازی داده‌های قدیمی: {e}")
            return 0
    
    def export_data(self, symbol: str, timeframe: str, 
                   file_path: str, format: str = "csv") -> bool:
        """خروجی گرفتن از داده‌ها"""
        try:
            data = self.load_ohlcv_data(symbol, timeframe)
            
            if data.empty:
                logger.warning(f"داده‌ای برای {symbol} ({timeframe}) یافت نشد")
                return False
            
            if format == "csv":
                data.to_csv(file_path)
            elif format == "json":
                data.to_json(file_path, orient='index', date_format='iso')
            elif format == "parquet":
                data.to_parquet(file_path)
            else:
                logger.error(f"فرمت {format} پشتیبانی نمی‌شود")
                return False
            
            logger.info(f"داده‌های {symbol} به {file_path} export شد")
            return True
            
        except Exception as e:
            logger.error(f"خطا در export داده‌های {symbol}: {e}")
            return False
    
    def _update_metadata(self, symbol: str, timeframe: str, 
                        data: pd.DataFrame, cursor):
        """بروزرسانی متادیتای داده‌ها"""
        if data.empty:
            return
        
        start_date = data.index[0].isoformat() if hasattr(data.index[0], 'isoformat') else str(data.index[0])
        end_date = data.index[-1].isoformat() if hasattr(data.index[-1], 'isoformat') else str(data.index[-1])
        
        cursor.execute('''
            INSERT OR REPLACE INTO data_metadata 
            (symbol, timeframe, last_update, data_count, start_date, end_date)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (
            symbol,
            timeframe,
            datetime.now().isoformat(),
            len(data),
            start_date,
            end_date
        ))
    
    def _calculate_date_span(self, start_date: str, end_date: str) -> int:
        """محاسبه فاصله زمانی به روز"""
        try:
            start = datetime.fromisoformat(start_date.replace('Z', '+00:00'))
            end = datetime.fromisoformat(end_date.replace('Z', '+00:00'))
            return (end - start).days
        except:
            return 0
