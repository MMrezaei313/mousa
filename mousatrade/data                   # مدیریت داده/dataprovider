"""
ØªØ§Ù…ÛŒÙ† Ú©Ù†Ù†Ø¯Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ MousaTrade
Ù…Ø¯ÛŒØ±ÛŒØª Ùˆ ÛŒÚ©Ù¾Ø§Ø±Ú†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import logging
from mousatrade.brokers import BrokerFactory

logger = logging.getLogger(__name__)

class DataProvider:
    """ØªØ§Ù…ÛŒÙ† Ú©Ù†Ù†Ø¯Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±"""
    
    def __init__(self):
        self.broker_factory = BrokerFactory()
        self.current_broker = None
        self.data_cache = {}
        self.cache_timeout = 300  # 5 minutes
        
    def set_broker(self, broker_name: str, api_key: str = None, secret: str = None) -> bool:
        """ØªÙ†Ø¸ÛŒÙ… Ø¨Ø±ÙˆÚ©Ø± ÙØ¹Ø§Ù„"""
        try:
            self.current_broker = self.broker_factory.create_broker(
                broker_name, api_key, secret
            )
            
            if self.current_broker:
                logger.info(f"âœ… Ø¨Ø±ÙˆÚ©Ø± {broker_name} Ø¨Ø±Ø§ÛŒ DataProvider ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯")
                return True
            else:
                logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ… Ø¨Ø±ÙˆÚ©Ø± {broker_name}")
                return False
                
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± ØªÙ†Ø¸ÛŒÙ… Ø¨Ø±ÙˆÚ©Ø±: {e}")
            return False
    
    def get_historical_data(self, symbol: str, timeframe: str = '1h', 
                          days: int = 30, use_cache: bool = True) -> pd.DataFrame:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ"""
        cache_key = f"{symbol}_{timeframe}_{days}"
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø´
        if use_cache and cache_key in self.data_cache:
            data, timestamp = self.data_cache[cache_key]
            if (datetime.now() - timestamp).total_seconds() < self.cache_timeout:
                logger.debug(f"ğŸ“¦ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ú©Ø´ Ø¨Ø±Ø§ÛŒ {symbol}")
                return data.copy()
        
        try:
            if not self.current_broker:
                logger.error("âŒ Ù‡ÛŒÚ† Ø¨Ø±ÙˆÚ©Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª")
                return pd.DataFrame()
            
            # Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡ Ø§Ø² Ø¨Ø±ÙˆÚ©Ø±
            data = self.current_broker.get_historical_data_with_indicators(
                symbol, timeframe, days
            )
            
            # Ù¾Ø±Ø¯Ø§Ø²Ø´ Ùˆ Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§
            processed_data = self._process_data(data)
            
            # Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø± Ú©Ø´
            self.data_cache[cache_key] = (processed_data.copy(), datetime.now())
            
            logger.info(f"ğŸ“Š Ø¯Ø±ÛŒØ§ÙØª {len(processed_data)} Ø¯Ø§Ø¯Ù‡ ØªØ§Ø±ÛŒØ®ÛŒ Ø¨Ø±Ø§ÛŒ {symbol}")
            return processed_data
            
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªØ§Ø±ÛŒØ®ÛŒ: {e}")
            return pd.DataFrame()
    
    def get_current_market_data(self, symbols: List[str]) -> Dict[str, Dict]:
        """Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙØ¹Ù„ÛŒ Ø¨Ø§Ø²Ø§Ø± Ø¨Ø±Ø§ÛŒ Ú†Ù†Ø¯ Ù†Ù…Ø§Ø¯"""
        try:
            if not self.current_broker:
                return {}
            
            market_data = {}
            for symbol in symbols:
                try:
                    market_info = self.current_broker.get_market_info(symbol)
                    if market_info:
                        market_data[symbol] = market_info
                except Exception as e:
                    logger.warning(f"Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ {symbol}: {e}")
                    market_data[symbol] = {"error": str(e)}
            
            return market_data
            
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²Ø§Ø±: {e}")
            return {}
    
    def get_technical_indicators(self, symbol: str, timeframe: str = '1h', 
                               days: int = 30) -> Dict:
        """Ø¯Ø±ÛŒØ§ÙØª Ø§ÛŒÙ†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ ØªÚ©Ù†ÛŒÚ©Ø§Ù„"""
        try:
            data = self.get_historical_data(symbol, timeframe, days)
            
            if data.empty:
                return {}
            
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§ÛŒÙ†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡
            indicators = self._calculate_advanced_indicators(data)
            
            return {
                "symbol": symbol,
                "timeframe": timeframe,
                "indicators": indicators,
                "last_updated": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"âŒ Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§ÛŒÙ†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§: {e}")
            return {}
    
    def _process_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """Ù¾Ø±Ø¯Ø§Ø²Ø´ Ùˆ Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§"""
        if data.empty:
            return data
        
        try:
            # Ø­Ø°Ù Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ØªÚ©Ø±Ø§Ø±ÛŒ
            data = data.drop_duplicates(subset=['timestamp'], keep='last')
            
            # Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø²Ù…Ø§Ù†
            data = data.sort_values('timestamp')
            
            # Ù¾Ø± Ú©Ø±Ø¯Ù† Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒç¼ºå¤±
            numeric_columns = ['open', 'high', 'low', 'close', 'volume']
            for col in numeric_columns:
                if col in data.columns:
                    data[col] = data[col].fillna(method='ffill')
            
            # Ø­Ø°Ù Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ outlier Ø´Ø¯ÛŒØ¯
            data = self._remove_price_outliers(data)
            
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³ØªÙˆÙ†â€ŒÙ‡Ø§ÛŒ Ø§Ø¶Ø§ÙÛŒ
            data['price_change'] = data['close'].pct_change()
            data['price_change_abs'] = data['close'].diff()
            
            return data
            
        except Exception as e:
            logger.warning(f"Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§: {e}")
            return data
    
    def _remove_price_outliers(self, data: pd.DataFrame, threshold: float = 0.1) -> pd.DataFrame:
        """Ø­Ø°Ù Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ outlier Ù‚ÛŒÙ…Øª"""
        try:
            if len(data) < 10:
                return data
            
            # Ù…Ø­Ø§Ø³Ø¨Ù‡ ØªØºÛŒÛŒØ±Ø§Øª Ù‚ÛŒÙ…Øª
            price_changes = data['close'].pct_change().abs()
            
            # Ø´Ù†Ø§Ø³Ø§ÛŒÛŒ outlierÙ‡Ø§ (ØªØºÛŒÛŒØ±Ø§Øª Ø¨ÛŒØ´ Ø§Ø² threshold)
            outlier_mask = price_changes > threshold
            
            # Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ outlierÙ‡Ø§ Ø¨Ø§ Ù…Ù‚Ø§Ø¯ÛŒØ± Ù…Ø¹Ù‚ÙˆÙ„
            if outlier_mask.any():
                data_clean = data.copy()
                for idx in data[outlier_mask].index:
                    prev_idx = data.index.get_loc(idx) - 1
                    if prev_idx >= 0:
                        prev_close = data.iloc[prev_idx]['close']
                        # Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ Ø¨Ø§ Ù…ÛŒØ§Ù†Ú¯ÛŒÙ† Ù‚ÛŒÙ…Øª Ù‚Ø¨Ù„ÛŒ Ùˆ Ø¨Ø¹Ø¯ÛŒ
                        next_idx = data.index.get_loc(idx) + 1
                        if next_idx < len(data):
                            next_close = data.iloc[next_idx]['close']
                            avg_price = (prev_close + next_close) / 2
                            data_clean.loc[idx, 'close'] = avg_price
                            # Ø¨Ù‡ Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ high/low Ø¨Ø± Ø§Ø³Ø§Ø³ close Ø¬Ø¯ÛŒØ¯
                            data_clean.loc[idx, 'high'] = max(avg_price, data_clean.loc[idx, 'high'])
                            data_clean.loc[idx, 'low'] = min(avg_price, data_clean.loc[idx, 'low'])
                
                return data_clean
            
            return data
            
        except Exception as e:
            logger.warning(f"Ø®Ø·Ø§ Ø¯Ø± Ø­Ø°Ù outlierÙ‡Ø§: {e}")
            return data
    
    def _calculate_advanced_indicators(self, data: pd.DataFrame) -> Dict:
        """Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§ÛŒÙ†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡"""
        try:
            if data.empty:
                return {}
            
            close = data['close']
            high = data['high']
            low = data['low']
            volume = data['volume']
            
            indicators = {}
            
            # Ù†ÙˆØ³Ø§Ù†â€ŒÚ¯Ø±Ù‡Ø§
            indicators['rsi'] = self._calculate_rsi(close)
            indicators['stoch_k'], indicators['stoch_d'] = self._calculate_stochastic(high, low, close)
            indicators['williams_r'] = self._calculate_williams_r(high, low, close)
            
            # Ø±ÙˆÙ†Ø¯
            indicators['adx'] = self._calculate_adx(high, low, close)
            indicators['macd'], indicators['macd_signal'] = self._calculate_macd(close)
            
            # Ù†ÙˆØ³Ø§Ù†
            indicators['atr'] = self._calculate_atr(high, low, close)
            indicators['bollinger_upper'], indicators['bollinger_lower'] = self._calculate_bollinger_bands(close)
            
            # Ø­Ø¬Ù…
            indicators['obv'] = self._calculate_obv(close, volume)
            indicators['volume_sma'] = volume.rolling(20).mean().iloc[-1]
            
            return indicators
            
        except Exception as e:
            logger.warning(f"Ø®Ø·Ø§ Ø¯Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§ÛŒÙ†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§ÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡: {e}")
            return {}
    
    # Ù…ØªØ¯Ù‡Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø§ÛŒÙ†Ø¯ÛŒÚ©Ø§ØªÙˆØ±Ù‡Ø§
    def _calculate_rsi(self, close, period=14):
        delta = close.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi.iloc[-1] if not rsi.empty else 50
    
    def _calculate_stochastic(self, high, low, close, k_period=14, d_period=3):
        low_min = low.rolling(window=k_period).min()
        high_max = high.rolling(window=k_period).max()
        stoch_k = 100 * (close - low_min) / (high_max - low_min)
        stoch_d = stoch_k.rolling(window=d_period).mean()
        return stoch_k.iloc[-1] if not stoch_k.empty else 50, stoch_d.iloc[-1] if not stoch_d.empty else 50
    
    def _calculate_williams_r(self, high, low, close, period=14):
        highest_high = high.rolling(window=period).max()
        lowest_low = low.rolling(window=period).min()
        williams_r = -100 * (highest_high - close) / (highest_high - lowest_low)
        return williams_r.iloc[-1] if not williams_r.empty else -50
    
    def _calculate_adx(self, high, low, close, period=14):
        # Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø³Ø§Ø¯Ù‡â€ŒØ´Ø¯Ù‡ ADX
        tr = np.maximum(high - low, np.maximum(abs(high - close.shift()), abs(low - close.shift())))
        atr = tr.rolling(period).mean()
        adx = atr / close * 100
        return adx.iloc[-1] if not adx.empty else 25
    
    def _calculate_macd(self, close, fast=12, slow=26, signal=9):
        ema_fast = close.ewm(span=fast).mean()
        ema_slow = close.ewm(span=slow).mean()
        macd = ema_fast - ema_slow
        macd_signal = macd.ewm(span=signal).mean()
        return macd.iloc[-1] if not macd.empty else 0, macd_signal.iloc[-1] if not macd_signal.empty else 0
    
    def _calculate_atr(self, high, low, close, period=14):
        tr1 = high - low
        tr2 = abs(high - close.shift())
        tr3 = abs(low - close.shift())
        tr = np.maximum(np.maximum(tr1, tr2), tr3)
        atr = tr.rolling(period).mean()
        return atr.iloc[-1] if not atr.empty else 0
    
    def _calculate_bollinger_bands(self, close, period=20, std=2):
        sma = close.rolling(period).mean()
        std_dev = close.rolling(period).std()
        upper_band = sma + (std_dev * std)
        lower_band = sma - (std_dev * std)
        return upper_band.iloc[-1] if not upper_band.empty else close.iloc[-1], lower_band.iloc[-1] if not lower_band.empty else close.iloc[-1]
    
    def _calculate_obv(self, close, volume):
        obv = (np.sign(close.diff()) * volume).fillna(0).cumsum()
        return obv.iloc[-1] if not obv.empty else 0
    
    def clear_cache(self):
        """Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ú©Ø´"""
        self.data_cache.clear()
        logger.info("ğŸ§¹ Ú©Ø´ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ Ø´Ø¯")
    
    def get_cache_info(self) -> Dict:
        """Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø´"""
        return {
            "cache_size": len(self.data_cache),
            "cache_timeout": self.cache_timeout,
            "cached_symbols": list(self.data_cache.keys())
        }
