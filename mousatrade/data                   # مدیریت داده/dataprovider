"""
تامین کننده داده‌های MousaTrade
مدیریت و یکپارچه‌سازی داده‌های بازار
"""

import pandas as pd
import numpy as np
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import logging
from mousatrade.brokers import BrokerFactory

logger = logging.getLogger(__name__)

class DataProvider:
    """تامین کننده داده‌های بازار"""
    
    def __init__(self):
        self.broker_factory = BrokerFactory()
        self.current_broker = None
        self.data_cache = {}
        self.cache_timeout = 300  # 5 minutes
        
    def set_broker(self, broker_name: str, api_key: str = None, secret: str = None) -> bool:
        """تنظیم بروکر فعال"""
        try:
            self.current_broker = self.broker_factory.create_broker(
                broker_name, api_key, secret
            )
            
            if self.current_broker:
                logger.info(f"✅ بروکر {broker_name} برای DataProvider تنظیم شد")
                return True
            else:
                logger.error(f"❌ خطا در تنظیم بروکر {broker_name}")
                return False
                
        except Exception as e:
            logger.error(f"❌ خطا در تنظیم بروکر: {e}")
            return False
    
    def get_historical_data(self, symbol: str, timeframe: str = '1h', 
                          days: int = 30, use_cache: bool = True) -> pd.DataFrame:
        """دریافت داده‌های تاریخی"""
        cache_key = f"{symbol}_{timeframe}_{days}"
        
        # بررسی کش
        if use_cache and cache_key in self.data_cache:
            data, timestamp = self.data_cache[cache_key]
            if (datetime.now() - timestamp).total_seconds() < self.cache_timeout:
                logger.debug(f"📦 استفاده از داده‌های کش برای {symbol}")
                return data.copy()
        
        try:
            if not self.current_broker:
                logger.error("❌ هیچ بروکری تنظیم نشده است")
                return pd.DataFrame()
            
            # دریافت داده از بروکر
            data = self.current_broker.get_historical_data_with_indicators(
                symbol, timeframe, days
            )
            
            # پردازش و پاکسازی داده‌ها
            processed_data = self._process_data(data)
            
            # ذخیره در کش
            self.data_cache[cache_key] = (processed_data.copy(), datetime.now())
            
            logger.info(f"📊 دریافت {len(processed_data)} داده تاریخی برای {symbol}")
            return processed_data
            
        except Exception as e:
            logger.error(f"❌ خطا در دریافت داده‌های تاریخی: {e}")
            return pd.DataFrame()
    
    def get_current_market_data(self, symbols: List[str]) -> Dict[str, Dict]:
        """دریافت داده‌های فعلی بازار برای چند نماد"""
        try:
            if not self.current_broker:
                return {}
            
            market_data = {}
            for symbol in symbols:
                try:
                    market_info = self.current_broker.get_market_info(symbol)
                    if market_info:
                        market_data[symbol] = market_info
                except Exception as e:
                    logger.warning(f"خطا در دریافت داده‌های {symbol}: {e}")
                    market_data[symbol] = {"error": str(e)}
            
            return market_data
            
        except Exception as e:
            logger.error(f"❌ خطا در دریافت داده‌های بازار: {e}")
            return {}
    
    def get_technical_indicators(self, symbol: str, timeframe: str = '1h', 
                               days: int = 30) -> Dict:
        """دریافت ایندیکاتورهای تکنیکال"""
        try:
            data = self.get_historical_data(symbol, timeframe, days)
            
            if data.empty:
                return {}
            
            # محاسبه ایندیکاتورهای پیشرفته
            indicators = self._calculate_advanced_indicators(data)
            
            return {
                "symbol": symbol,
                "timeframe": timeframe,
                "indicators": indicators,
                "last_updated": datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"❌ خطا در محاسبه ایندیکاتورها: {e}")
            return {}
    
    def _process_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """پردازش و پاکسازی داده‌ها"""
        if data.empty:
            return data
        
        try:
            # حذف داده‌های تکراری
            data = data.drop_duplicates(subset=['timestamp'], keep='last')
            
            # مرتب‌سازی بر اساس زمان
            data = data.sort_values('timestamp')
            
            # پر کردن داده‌های缺失
            numeric_columns = ['open', 'high', 'low', 'close', 'volume']
            for col in numeric_columns:
                if col in data.columns:
                    data[col] = data[col].fillna(method='ffill')
            
            # حذف داده‌های outlier شدید
            data = self._remove_price_outliers(data)
            
            # محاسبه ستون‌های اضافی
            data['price_change'] = data['close'].pct_change()
            data['price_change_abs'] = data['close'].diff()
            
            return data
            
        except Exception as e:
            logger.warning(f"خطا در پردازش داده‌ها: {e}")
            return data
    
    def _remove_price_outliers(self, data: pd.DataFrame, threshold: float = 0.1) -> pd.DataFrame:
        """حذف داده‌های outlier قیمت"""
        try:
            if len(data) < 10:
                return data
            
            # محاسبه تغییرات قیمت
            price_changes = data['close'].pct_change().abs()
            
            # شناسایی outlierها (تغییرات بیش از threshold)
            outlier_mask = price_changes > threshold
            
            # جایگزینی outlierها با مقادیر معقول
            if outlier_mask.any():
                data_clean = data.copy()
                for idx in data[outlier_mask].index:
                    prev_idx = data.index.get_loc(idx) - 1
                    if prev_idx >= 0:
                        prev_close = data.iloc[prev_idx]['close']
                        # جایگزینی با میانگین قیمت قبلی و بعدی
                        next_idx = data.index.get_loc(idx) + 1
                        if next_idx < len(data):
                            next_close = data.iloc[next_idx]['close']
                            avg_price = (prev_close + next_close) / 2
                            data_clean.loc[idx, 'close'] = avg_price
                            # به روزرسانی high/low بر اساس close جدید
                            data_clean.loc[idx, 'high'] = max(avg_price, data_clean.loc[idx, 'high'])
                            data_clean.loc[idx, 'low'] = min(avg_price, data_clean.loc[idx, 'low'])
                
                return data_clean
            
            return data
            
        except Exception as e:
            logger.warning(f"خطا در حذف outlierها: {e}")
            return data
    
    def _calculate_advanced_indicators(self, data: pd.DataFrame) -> Dict:
        """محاسبه ایندیکاتورهای پیشرفته"""
        try:
            if data.empty:
                return {}
            
            close = data['close']
            high = data['high']
            low = data['low']
            volume = data['volume']
            
            indicators = {}
            
            # نوسان‌گرها
            indicators['rsi'] = self._calculate_rsi(close)
            indicators['stoch_k'], indicators['stoch_d'] = self._calculate_stochastic(high, low, close)
            indicators['williams_r'] = self._calculate_williams_r(high, low, close)
            
            # روند
            indicators['adx'] = self._calculate_adx(high, low, close)
            indicators['macd'], indicators['macd_signal'] = self._calculate_macd(close)
            
            # نوسان
            indicators['atr'] = self._calculate_atr(high, low, close)
            indicators['bollinger_upper'], indicators['bollinger_lower'] = self._calculate_bollinger_bands(close)
            
            # حجم
            indicators['obv'] = self._calculate_obv(close, volume)
            indicators['volume_sma'] = volume.rolling(20).mean().iloc[-1]
            
            return indicators
            
        except Exception as e:
            logger.warning(f"خطا در محاسبه ایندیکاتورهای پیشرفته: {e}")
            return {}
    
    # متدهای محاسبه ایندیکاتورها
    def _calculate_rsi(self, close, period=14):
        delta = close.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi.iloc[-1] if not rsi.empty else 50
    
    def _calculate_stochastic(self, high, low, close, k_period=14, d_period=3):
        low_min = low.rolling(window=k_period).min()
        high_max = high.rolling(window=k_period).max()
        stoch_k = 100 * (close - low_min) / (high_max - low_min)
        stoch_d = stoch_k.rolling(window=d_period).mean()
        return stoch_k.iloc[-1] if not stoch_k.empty else 50, stoch_d.iloc[-1] if not stoch_d.empty else 50
    
    def _calculate_williams_r(self, high, low, close, period=14):
        highest_high = high.rolling(window=period).max()
        lowest_low = low.rolling(window=period).min()
        williams_r = -100 * (highest_high - close) / (highest_high - lowest_low)
        return williams_r.iloc[-1] if not williams_r.empty else -50
    
    def _calculate_adx(self, high, low, close, period=14):
        # محاسبه ساده‌شده ADX
        tr = np.maximum(high - low, np.maximum(abs(high - close.shift()), abs(low - close.shift())))
        atr = tr.rolling(period).mean()
        adx = atr / close * 100
        return adx.iloc[-1] if not adx.empty else 25
    
    def _calculate_macd(self, close, fast=12, slow=26, signal=9):
        ema_fast = close.ewm(span=fast).mean()
        ema_slow = close.ewm(span=slow).mean()
        macd = ema_fast - ema_slow
        macd_signal = macd.ewm(span=signal).mean()
        return macd.iloc[-1] if not macd.empty else 0, macd_signal.iloc[-1] if not macd_signal.empty else 0
    
    def _calculate_atr(self, high, low, close, period=14):
        tr1 = high - low
        tr2 = abs(high - close.shift())
        tr3 = abs(low - close.shift())
        tr = np.maximum(np.maximum(tr1, tr2), tr3)
        atr = tr.rolling(period).mean()
        return atr.iloc[-1] if not atr.empty else 0
    
    def _calculate_bollinger_bands(self, close, period=20, std=2):
        sma = close.rolling(period).mean()
        std_dev = close.rolling(period).std()
        upper_band = sma + (std_dev * std)
        lower_band = sma - (std_dev * std)
        return upper_band.iloc[-1] if not upper_band.empty else close.iloc[-1], lower_band.iloc[-1] if not lower_band.empty else close.iloc[-1]
    
    def _calculate_obv(self, close, volume):
        obv = (np.sign(close.diff()) * volume).fillna(0).cumsum()
        return obv.iloc[-1] if not obv.empty else 0
    
    def clear_cache(self):
        """پاکسازی کش"""
        self.data_cache.clear()
        logger.info("🧹 کش داده‌ها پاکسازی شد")
    
    def get_cache_info(self) -> Dict:
        """دریافت اطلاعات کش"""
        return {
            "cache_size": len(self.data_cache),
            "cache_timeout": self.cache_timeout,
            "cached_symbols": list(self.data_cache.keys())
        }
