"""
مدیریت سایز پوزیشن
"""

import numpy as np
from typing import Dict, List, Optional, Tuple
from enum import Enum
import logging
from dataclasses import dataclass

logger = logging.getLogger(__name__)

class PositionSizingMethod(Enum):
    FIXED_PERCENTAGE = "FIXED_PERCENTAGE"      # درصد ثابت
    KELLY_CRITERION = "KELLY_CRITERION"        # معیار کلی
    OPTIMAL_F = "OPTIMAL_F"                    # فرمول بهینه f
    VOLATILITY_ADJUSTED = "VOLATILITY_ADJUSTED" # تعدیل بر اساس نوسان
    MARTINGALE = "MARTINGALE"                  # مارتینگل (توصیه نمی‌شود)
    ANTI_MARTINGALE = "ANTI_MARTINGALE"        # ضد مارتینگل

@dataclass
class PositionSizeResult:
    """نتیجه محاسبه سایز پوزیشن"""
    position_size: float
    method: PositionSizingMethod
    risk_per_trade: float
    suggested_leverage: float
    max_position_value: float
    stop_loss_distance: float
    reasoning: Dict

class PositionSizer:
    """محاسبه‌گر سایز پوزیشن"""
    
    def __init__(self, account_balance: float = 10000):
        self.account_balance = account_balance
        self.default_risk_per_trade = 0.02  # 2% ریسک در هر معامله
        self.max_portfolio_risk = 0.15      # 15% ریسک کل پرتفوی
        self.min_position_size = 10         # حداقل سایز پوزیشن (USD)
        
    def calculate_position_size(self, 
                              symbol: str,
                              entry_price: float,
                              stop_loss: float,
                              confidence: float,
                              volatility: float,
                              method: PositionSizingMethod = PositionSizingMethod.VOLATILITY_ADJUSTED,
                              risk_level: str = "MEDIUM") -> PositionSizeResult:
        """محاسبه سایز پوزیشن"""
        try:
            # محاسبه فاصله ریسک
            risk_distance = self._calculate_risk_distance(entry_price, stop_loss)
            
            if method == PositionSizingMethod.FIXED_PERCENTAGE:
                result = self._fixed_percentage_method(risk_distance, confidence, risk_level)
            elif method == PositionSizingMethod.VOLATILITY_ADJUSTED:
                result = self._volatility_adjusted_method(risk_distance, confidence, volatility, risk_level)
            elif method == PositionSizingMethod.KELLY_CRITERION:
                result = self._kelly_criterion_method(risk_distance, confidence, risk_level)
            elif method == PositionSizingMethod.OPTIMAL_F:
                result = self._optimal_f_method(risk_distance, confidence, risk_level)
            else:
                result = self._fixed_percentage_method(risk_distance, confidence, risk_level)
            
            # محاسبه اهرم پیشنهادی
            suggested_leverage = self._calculate_suggested_leverage(volatility, risk_level)
            
            # محاسبه حداکثر ارزش پوزیشن
            max_position_value = result.position_size * suggested_leverage
            
            return PositionSizeResult(
                position_size=result.position_size,
                method=method,
                risk_per_trade=result.risk_per_trade,
                suggested_leverage=suggested_leverage,
                max_position_value=max_position_value,
                stop_loss_distance=risk_distance,
                reasoning=result.reasoning
            )
            
        except Exception as e:
            logger.error(f"خطا در محاسبه سایز پوزیشن برای {symbol}: {e}")
            return self._get_default_result()
    
    def _fixed_percentage_method(self, risk_distance: float,
                               confidence: float,
                               risk_level: str) -> PositionSizeResult:
        """روش درصد ثابت"""
        # تنظیم ریسک بر اساس سطح ریسک
        risk_multipliers = {
            "LOW": 0.5,
            "MEDIUM": 1.0,
            "HIGH": 1.5,
            "VERY_HIGH": 2.0
        }
        
        multiplier = risk_multipliers.get(risk_level, 1.0)
        base_risk = self.default_risk_per_trade * multiplier
        
        # تعدیل بر اساس اطمینان
        adjusted_risk = base_risk * confidence
        
        # محاسبه سایز پوزیشن
        risk_amount = self.account_balance * adjusted_risk
        position_size = risk_amount / risk_distance if risk_distance > 0 else 0
        
        # اعمال محدودیت‌ها
        position_size = self._apply_position_limits(position_size)
        
        return PositionSizeResult(
            position_size=position_size,
            method=PositionSizingMethod.FIXED_PERCENTAGE,
            risk_per_trade=adjusted_risk,
            suggested_leverage=1.0,
            max_position_value=position_size,
            stop_loss_distance=risk_distance,
            reasoning={
                "base_risk": base_risk,
                "confidence_multiplier": confidence,
                "risk_level_multiplier": multiplier,
                "risk_amount": risk_amount
            }
        )
    
    def _volatility_adjusted_method(self, risk_distance: float,
                                  confidence: float,
                                  volatility: float,
                                  risk_level: str) -> PositionSizeResult:
        """روش تعدیل بر اساس نوسان"""
        # ریسک پایه بر اساس نوسان
        if volatility < 0.01:
            base_risk = self.default_risk_per_trade * 1.5  # افزایش ریسک برای نوسان پایین
        elif volatility < 0.03:
            base_risk = self.default_risk_per_trade
        elif volatility < 0.06:
            base_risk = self.default_risk_per_trade * 0.7  # کاهش ریسک برای نوسان متوسط
        else:
            base_risk = self.default_risk_per_trade * 0.4  # کاهش شدید برای نوسان بالا
        
        # تعدیل بر اساس سطح ریسک
        risk_multipliers = {
            "LOW": 0.6,
            "MEDIUM": 1.0,
            "HIGH": 1.3,
            "VERY_HIGH": 1.6
        }
        
        multiplier = risk_multipliers.get(risk_level, 1.0)
        adjusted_risk = base_risk * multiplier * confidence
        
        # محاسبه سایز پوزیشن
        risk_amount = self.account_balance * adjusted_risk
        position_size = risk_amount / risk_distance if risk_distance > 0 else 0
        
        # اعمال محدودیت‌ها
        position_size = self._apply_position_limits(position_size)
        
        return PositionSizeResult(
            position_size=position_size,
            method=PositionSizingMethod.VOLATILITY_ADJUSTED,
            risk_per_trade=adjusted_risk,
            suggested_leverage=1.0,
            max_position_value=position_size,
            stop_loss_distance=risk_distance,
            reasoning={
                "base_risk": base_risk,
                "volatility": volatility,
                "risk_level_multiplier": multiplier,
                "confidence_multiplier": confidence,
                "risk_amount": risk_amount
            }
        )
    
    def _kelly_criterion_method(self, risk_distance: float,
                              confidence: float,
                              risk_level: str) -> PositionSizeResult:
        """روش معیار کلی"""
        # فرض win rate و reward/risk ratio
        win_rate = confidence * 0.8  # تبدیل اطمینان به win rate
        reward_risk_ratio = 2.0      # نسبت سود به ضرر
        
        # فرمول کلی
        kelly_fraction = win_rate - (1 - win_rate) / reward_risk_ratio
        
        # محدود کردن به حداکثر 25%
        kelly_fraction = min(kelly_fraction, 0.25)
        
        # تعدیل بر اساس سطح ریسک (نصف کلی برای محافظه‌کاری)
        risk_multipliers = {
            "LOW": 0.25,
            "MEDIUM": 0.5,
            "HIGH": 0.75,
            "VERY_HIGH": 1.0
        }
        
        multiplier = risk_multipliers.get(risk_level, 0.5)
        adjusted_fraction = kelly_fraction * multiplier
        
        # محاسبه سایز پوزیشن
        risk_amount = self.account_balance * adjusted_fraction
        position_size = risk_amount / risk_distance if risk_distance > 0 else 0
        
        # اعمال محدودیت‌ها
        position_size = self._apply_position_limits(position_size)
        
        return PositionSizeResult(
            position_size=position_size,
            method=PositionSizingMethod.KELLY_CRITERION,
            risk_per_trade=adjusted_fraction,
            suggested_leverage=1.0,
            max_position_value=position_size,
            stop_loss_distance=risk_distance,
            reasoning={
                "kelly_fraction": kelly_fraction,
                "win_rate": win_rate,
                "reward_risk_ratio": reward_risk_ratio,
                "risk_level_multiplier": multiplier,
                "risk_amount": risk_amount
            }
        )
    
    def _optimal_f_method(self, risk_distance: float,
                        confidence: float,
                        risk_level: str) -> PositionSizeResult:
        """روش فرمول بهینه f"""
        # این یک پیاده‌سازی ساده شده است
        # در عمل نیاز به داده‌های تاریخی دقیق دارد
        
        # فرض win rate و payoff ratio
        win_rate = confidence * 0.7
        avg_win = risk_distance * 2  # میانگین سود
        avg_loss = risk_distance      # میانگین ضرر
        
        # محاسبه f بهینه
        if avg_loss > 0:
            f = win_rate - (1 - win_rate) / (avg_win / avg_loss)
        else:
            f = 0.1  # مقدار پیش‌فرض
        
        # محدود کردن f
        f = max(0.01, min(f, 0.3))
        
        # تعدیل بر اساس سطح ریسک
        risk_multipliers = {
            "LOW": 0.3,
            "MEDIUM": 0.6,
            "HIGH": 0.9,
            "VERY_HIGH": 1.2
        }
        
        multiplier = risk_multipliers.get(risk_level, 0.6)
        adjusted_f = f * multiplier
        
        # محاسبه سایز پوزیشن
        risk_amount = self.account_balance * adjusted_f
        position_size = risk_amount / risk_distance if risk_distance > 0 else 0
        
        # اعمال محدودیت‌ها
        position_size = self._apply_position_limits(position_size)
        
        return PositionSizeResult(
            position_size=position_size,
            method=PositionSizingMethod.OPTIMAL_F,
            risk_per_trade=adjusted_f,
            suggested_leverage=1.0,
            max_position_value=position_size,
            stop_loss_distance=risk_distance,
            reasoning={
                "optimal_f": f,
                "win_rate": win_rate,
                "avg_win": avg_win,
                "avg_loss": avg_loss,
                "risk_level_multiplier": multiplier,
                "risk_amount": risk_amount
            }
        )
    
    def _calculate_risk_distance(self, entry_price: float, stop_loss: float) -> float:
        """محاسبه فاصله ریسک"""
        return abs(entry_price - stop_loss) / entry_price
    
    def _calculate_suggested_leverage(self, volatility: float, risk_level: str) -> float:
        """محاسبه اهرم پیشنهادی"""
        # اهرم پایه بر اساس نوسان
        if volatility < 0.01:
            base_leverage = 5.0
        elif volatility < 0.02:
            base_leverage = 3.0
        elif volatility < 0.04:
            base_leverage = 2.0
        elif volatility < 0.06:
            base_leverage = 1.5
        else:
            base_leverage = 1.0
        
        # تعدیل بر اساس سطح ریسک
        leverage_multipliers = {
            "LOW": 0.5,
            "MEDIUM": 1.0,
            "HIGH": 1.5,
            "VERY_HIGH": 2.0
        }
        
        multiplier = leverage_multipliers.get(risk_level, 1.0)
        return base_leverage * multiplier
    
    def _apply_position_limits(self, position_size: float) -> float:
        """اعمال محدودیت‌های سایز پوزیشن"""
        # حداقل سایز
        position_size = max(position_size, self.min_position_size)
        
        # حداکثر سایز (50% سرمایه)
        max_size = self.account_balance * 0.5
        position_size = min(position_size, max_size)
        
        return position_size
    
    def _get_default_result(self) -> PositionSizeResult:
        """نتیجه پیش‌فرض در صورت خطا"""
        return PositionSizeResult(
            position_size=self.min_position_size,
            method=PositionSizingMethod.FIXED_PERCENTAGE,
            risk_per_trade=0.01,
            suggested_leverage=1.0,
            max_position_value=self.min_position_size,
            stop_loss_distance=0.0,
            reasoning={"error": "خطا در محاسبه"}
        )
